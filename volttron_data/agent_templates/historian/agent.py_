"""
Agent documentation goes here.
"""

__docformat__ = 'reStructuredText'

import logging
import sys
import foo_db
from volttron.platform.agent import utils
from volttron.platform.agent.base_historian import BaseHistorian

_log = logging.getLogger(__name__)
utils.setup_logging()
__version__ = "__version_string__"


def historian(config_path, **kwargs):
    """
    Parses the Agent configuration and returns an instance of
    the agent created using that configuration.

    :param config_path: Path to a configuration file.

    :type config_path: str
    :returns: `__class_name__`
    :rtype: `__class_name__`
    """

    if isinstance(config_path, dict):
        config_dict = config_path
    else:
        config_dict = utils.load_config(config_path)

    # Gather all settings from configuration into kwargs.
    # This ensures that settings common to all historians
    # are passed to BaseHistorian.
    utils.update_kwargs_with_config(kwargs, config_dict)
    return __class_name__(**kwargs)


class __class_name__(BaseHistorian):
    """
    Document historian here.
    """

    def __init__(self, connection_parameters={},
                 **kwargs):
        # The publish_to_historian function will run in a
        # separate thread unless you change this to True.
        # Unless you need to interact with the VOLTTRON platform
        # leave this unchanged.
        kwargs["process_loop_in_greenlet"] = False
        super(__class_name__, self).__init__(**kwargs)

        self.db_connection = None

        # The base historian handles the interaction with the
        # configuration store.
        config = {"connection_parameters": connection_parameters}
        # Add our settings to the base historians default settings.
        self.update_default_config(config)

    def configure(self, configuration):
        # The base historian will call this whenever the
        # Historian is reconfigured in the main process thread.

        # If the Historian is already running historian_teardown
        # will be called before this is called and
        # historian_setup will be called afterwards.

        connection_parameters = configuration["connection_parameters"]

        if not isinstance(connection_parameters, dict):
            _log.warning("Supplied connection_parameters is not a dict, ignored")
            connection_parameters = {}

        self.db_address = connection_parameters.get("address")
        self.db_port = connection_parameters.get("port")

    def publish_to_historian(self, to_publish_list):
        # Called automatically by the BaseHistorian class when data is available to be
        # published.

        # This is run in a separate thread from the main agent thread. This means that
        # this function may block for a short period of time without fear of
        # blocking the main agent gevent loop.

        # Historians may not interact with the VOLTTRON platform directly from
        # this function unless kwargs["process_loop_in_greenlet"] is set to
        # True in __init__ which will cause this function to be run in the
        # main Agent thread.

        # to_publish_list is a list of dictionaries of the form:
        # {'timestamp': <datetime object>,
        #  'source': <"scrape", "record", "log", or "analysis">, # "scrape" is device data
        #  'topic': <str>,
        #  'value': <value>, # may be any value that can be serialized with json.
        #  'headers': <headers dictionary>,
        #  'meta': <meta data dictionary>}

        # Ideally a historian should try to batch up the values in to_publish_list
        # in a way that is appropriate for the storage mechanism and publish
        # everything in one shot.

        # Once data is published the published values must be reported to the
        # BaseHistorian class by either calling self.report_handled or
        # self.report_all_handled.

        # If a historian can not publish everything in a single batch then
        # self.report_handled must be called individually on every item in
        # to_publish_list that was published.

        # If everything is published in a single batch then self.report_all_handled
        # must be called.

        _log.debug("publish_to_historian number of items: {}"
                   .format(len(to_publish_list)))

        # Here it may be appropriate to check to see if our connection is still
        # active and restoring it as needed.
        alive = False
        if self.db_connection is not None:
            alive = self.db_connection.is_alive()

        if not alive:
            self.historian_setup()

        # If our connection is down leave without attempting to publish.
        # Publish failure will automatically trigger the BaseHistorian to
        # set the health of the agent accordingly.
        if self.db_connection is None:
            return

        # Example separate item publish
        for item in to_publish_list:
            try:
                # The details of how to publish data will be data store specific.
                self.db_connection.publish(item["topic"], item["source"], item["value"])
                self.report_handled(item)
            except StandardError as e:
                _log.error("Failed to publish {}: {}".format(item, repr(e))

        #Example batch publish
        batch = [(item["topic"], item["source"], item["value"]) for item in to_publish_list]

        try:
            # The details of how to publish batch data will be data store specific.
            self.db_connection.batch_publish(batch)
            self.report_all_handled()
        except StandardError:
                _log.error("Failed to publish {}".format(repr(e))

    def historian_setup(self):
        # Setup any connection needed for this historian.
        # If a connection does not need to be maintained this function may be deleted.

        # This is called from the same thread as publish_to_historian.

        # It is called after configure is called at startup
        # and every time the Historian is reconfigured.

        # If the connection is lost it is up to the Historian to
        # recreate it if needed, often by calling this function to
        # restore connectivity.

        # This is a convenience to allow us to call this any time we like to
        # restore a connection.
        self.historian_teardown()
        try:
            self.db_connection = foo_db.connect(self.db_address, self.db_port)
        except StandardError as e:
            _log.error("Failed to create data base connection: {}".format(e))


    def historian_teardown(self):
        # Kill the connection if needed.
        # If a connection does not need to be maintained this function may be deleted.
        # This is called to shut down the connection before reconfiguration.
        if self.db_connection is not None:
            self.db_connection.close()
            self.db_connection = None

def main():
    """Main method called to start the agent."""
    utils.vip_main(historian, __identity__
                   version=__version__)


if __name__ == '__main__':
    # Entry point for script
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        pass
