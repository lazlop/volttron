"""
Agent documentation goes here.
"""

__docformat__ = 'reStructuredText'

import logging
import sys
from volttron.platform.agent import utils
from volttron.platform.vip.agent import Agent, Core, RPC

_log = logging.getLogger(__name__)
utils.setup_logging()
__version__ = "__version_string__"


def historian(config_path, **kwargs):
    """
    Parses the Agent configuration and returns an instance of
    the agent created using that configuration.

    :param config_path: Path to a configuration file.

    :type config_path: str
    :returns: `__class_name__`
    :rtype: `__class_name__`
    """

    if isinstance(config_path, dict):
        config_dict = config_path
    else:
        config_dict = utils.load_config(config_path)

    # Gather all settings from configuration into kwargs.
    # This ensures that settings common to all historians
    # are passed to BaseHistorian.
    utils.update_kwargs_with_config(kwargs, config_dict)
    return __class_name__(**kwargs)


class __class_name__(BaseHistorian):
    """
    Document historian here.
    """

    def __init__(self, connection_parameters={},
                 **kwargs):
        # The publish_to_historian function will run in a
        # separate thread unless you change this to True.
        # Unless you need to interact with the VOLTTRON platform
        # leave this unchanged.
        kwargs["process_loop_in_greenlet"] = False
        super(__class_name__, self).__init__(**kwargs)

        self.db_connection = None

        # The base historian handles the interaction with the
        # configuration store.
        config = {"connection_parameters": connection_parameters}
        # Add our settings to the base historians default settings.
        self.update_default_config(config)

    def configure(self, configuration):
        """
        The base historian will call this whenever the
        Historian is reconfigured in the main process thread.

        If the Historian is already running historian_teardown
        will be called before this is called and
        historian_setup will be called afterwards.
        """
        connection_parameters = configuration["connection_parameters"]

        if not isinstance(connection_parameters, dict):
            _log.warning("Supplied connection_parameters is not a dict, ignored")
            connection_parameters = {}

        self.db_address = connection_parameters.get("address")
        self.db_port = connection_parameters.get("port")

    def publish_to_historian(self, to_publish_list):
        _log.debug("publish_to_historian number of items: {}"
                   .format(len(to_publish_list)))
        current_time = self.timestamp()
        last_time = self._last_timeout
        _log.debug('Last timeout: {} current time: {}'.format(last_time,
                                                              current_time))
        if self._last_timeout:
            # if we failed we need to wait 60 seconds before we go on.
            if self.timestamp() < self._last_timeout + 60:
                _log.debug('Not allowing send < 60 seconds from failure')
                return
        if not self._target_platform:
            self.historian_setup()
        if not self._target_platform:
            _log.debug('Could not connect to target')
            return

        to_send = []
        for x in to_publish_list:
            topic = x['topic']
            headers = x['value']['headers']
            message = x['value']['message']

            if self.gather_timing_data:
                add_timing_data_to_header(
                    headers,
                    self.core.agent_uuid or self.core.identity,
                    "forwarded")

            to_send.append({'topic': topic,
                            'headers': headers,
                            'message': message})
        with gevent.Timeout(30):
            try:
                _log.debug("Sending to destination historian.")
                self._target_platform.vip.rpc.call(
                    self.destination_historian_identity, 'insert',
                    to_send).get(timeout=10)
                self.report_all_handled()
            except gevent.Timeout:
                self._last_timeout = self.timestamp()
                self._target_platform.core.stop()
                self._target_platform = None
                _log.error("Timeout when attempting to publish to target.")
                self.vip.health.set_status(
                    STATUS_BAD, "Timeout occurred")

    def historian_setup(self):
        """
        Setup any connection needed for this historian.
        This is called from the same thread as publish_to_historian.

        It is called after configure is called at startup
        and every time the Historian is reconfigured.

        If the connection is lost it is up to the Historian to
        recreate it if needed, often by calling this function to
        restore connectivity.
        """
        self.historian_teardown()
        try:
            self.db_connection = foo_db.connect(self.db_address, self.db_port)
        except StandardError as e:
            _log.error("Failed to create data base connection: {}".format(e))


    def historian_teardown(self):
        # Kill the connection if it is up.
        if self.db_connection is not None:
            self.db_connection.close()
            self.db_connection = None

def main():
    """Main method called to start the agent."""
    utils.vip_main(historian, __identity__
                   version=__version__)


if __name__ == '__main__':
    # Entry point for script
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        pass
